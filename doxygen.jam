import common ;
import feature ;
import generators ;
import path ;
import print ;
import project ;
import toolset ;
import type ;


feature.feature doxygen-param : : free ;


type.register DOXYFILE : doxyfile ;
type.register DOXYGEN_XML_MULTIFILE : xml-dir : XML ;


rule init ( command * ) {
  if ! $(.initialized) {
    .initialized = true ;

    generators.register-composing doxygen.headers-to-doxyfile
        : H HPP CPP MARKDOWN : DOXYFILE ;
    generators.register-standard doxygen.run
        : DOXYFILE : DOXYGEN_XML_MULTIFILE ;
    generators.register-xslt doxygen.collect
        : DOXYGEN_XML_MULTIFILE : DOXYGEN_XML ;
    # generators.register-standard doxygen.xml-dir-to-boostbook
    #     : DOXYGEN_XML_MULTIFILE : BOOSTBOOK : <doxygen.processor>doxproc ;
    # generators.register-xslt doxygen.xml-to-boostbook
    #     : DOXYGEN_XML : BOOSTBOOK : <doxygen.processor>xsltproc ;
    # generators.register-standard doxygen.run
    #     : DOXYFILE : DOXYGEN_HTML_MULTIFILE ;
    # generators.register-standard doxygen.html-redirect
    #     : DOXYGEN_HTML_MULTIFILE : DOXYGEN_HTML ;
    # generators.register-standard doxygen.copy-latex-pngs
    #     : DOXYGEN_HTML : DOXYGEN_XML_IMAGES ;

    .doxygen
      = [ common.get-invocation-command doxygen
        : doxygen
        : $(.doxygen)
        : [ common.get-program-files-dir ]
        ] ;
  }
}


rule xml
  ( target
  : sources +
  : requirements *
  : default-build *
  : usage-requirements *
  )
{
  local project = [ project.current ] ;

  local doxydir = $(target:B=$(target:B)-xml) ;
  local doxyfile = $(doxydir:S=.doxyfile) ;
  doxyfile $(doxyfile)
    : $(sources)
    : $(requirements)
      <doxygen-param>GENERATE_HTML=NO
      <doxygen-param>GENERATE_XML=YES
      <doxygen-param>XML_OUTPUT=$(doxydir)
    : $(default-build)
    ;
  $(project).mark-target-as-explicit $(doxyfile) ;

  local doxydir-touch = $(doxydir)/touch ;
  echo TOUCH $(doxydir-touch) ;
  doxygen-xml-multifile $(doxydir-touch)
      : $(doxyfile)
      : $(requirements)
      : $(default-build)
      ;
  $(project).mark-target-as-explicit $(doxydir) ;

  #   import targets ;
  #   # The resulting BoostBook file is generated by the processor tool. The
  #   # tool can be either the xsltproc plus accompanying XSL scripts. Or it
  #   # can be the python doxproc.py script.
  #   targets.create-typed-target BOOSTBOOK : $(project) : $(target-xml)
  #       : $(doxydir)
  #       : $(requirements)
  #       : $(default-build) ;
  #   $(project).mark-target-as-explicit $(target-xml) ;
  #
  # alias $(target) : $(target-xml) ;
  # #     stage $(target:S=.xml)  # Name.
  # #         : $(target-xml)  # Sources.
  # #         : $(requirements)
  # #             <location>$(location-xml:E=.)
  # #             <name>$(target:S=.xml)
  # #         : $(default-build) ;
  # #     $(project).mark-target-as-explicit $(target:S=.xml) ;
  # #
  # #     # TODO: See why this alias target is used here instead of simply naming
  # #     # the previous stage target $(target) and having it specify the alias
  # #     # target's usage requirements directly.
  # #     alias $(target) : : $(requirements) : $(default-build) :
  # #         $(usage-requirements) <dependency>$(target:S=.xml) ;
}


toolset.uses-features doxygen.run : <doxygen-param> ;

rule headers-to-doxyfile ( target : sources * : properties * ) {
    local text = "# Autogenerated" "GENERATE_LATEX = NO" ;

    local output-dir ;
    # Translate <doxygen-param> into configuration parameters.
    for local param in [ feature.get-values <doxygen-param> : $(properties) ] {
      local namevalue = [ MATCH "([^=]*)=(.*)" : $(param) ] ;
      if $(namevalue[1]) = OUTPUT_DIRECTORY {
        output-dir = [ utility.unquote $(namevalue[2]) ] ;
      } else {
        text += "$(namevalue[1]) = $(namevalue[2])" ;
      }
    }

    if ! $(output-dir) {
      output-dir = [ on $(target) return $(LOCATE) ] ;
    }
    text += "OUTPUT_DIRECTORY = \"$(output-dir)\"" ;

    local inputs ;
    for local input in $(sources:G=) { inputs += \"$(input)\" ; }

    # Doxygen generates LaTex by default. So disable it unconditionally, or at
    # least until someone needs, and hence writes support for, LaTex output.
    text += "INPUT = $(inputs:J= )" ;
    text += "" ;
    print.output $(target) ;
    print.text $(text) : overwrite ;
}


# toolset.uses-features doxygen.run : <doxygen.rmdir> "<doxygen:param>" ;

rule run ( target : source : properties * ) {
  echo TARGET $(target) ;
  doxygen-action $(target) : $(source) ;
  COMMAND on $(target) = $(.doxygen) ;
  RM on $(target) = [ common.rm-command ] ;
  TOUCH on $(target) = [ common.file-touch-command ] ;

  local basedir = [ path.make [ on $(target) return $(LOCATE) ] ] ;
  local pattern = [ path.join $(basedir) $(target:B:S=) *.xml ] ;
  PATTERN on $(target) = [ path.native $(pattern) ] ;
}


actions doxygen-action {
  $(RM) "$(PATTERN)" && $(COMMAND:J= ) "$(>)" && $(TOUCH) "$(<)"
}


# Collect the set of Doxygen XML files into a single XML source file that can be
# handled by an XSLT processor. The source is completely ignored (see
# doxygen-action), because this action picks up the Doxygen XML index file xml/
# index.xml. This is because we can not teach Doxygen to act like a NORMAL
# program and take a "-o output.xml" argument (grrrr). The target of the
# collection will be a single Doxygen XML file.
rule collect ( target : source : properties * ) {
  check-boostbook ;
  local collect-xsl-dir
      = [ path.native [ path.join [ boostbook.xsl-dir ] doxygen collect ] ] ;
  local source-path
      = [ path.make [ on $(source) return $(LOCATE) ] ] ;
  local collect-path
      = [ path.root [ path.join $(source-path) $(source:B) ] [ path.pwd ] ] ;
  local native-path
      = [ path.native $(collect-path) ] ;
  local real-source
      = [ path.native [ path.join $(collect-path) index.xml ] ] ;
  xsltproc.xslt $(target) : $(real-source) $(collect-xsl-dir:S=.xsl)
      : <xsl:param>doxygen.xml.path=$(native-path) ;
}
